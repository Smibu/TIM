<!doctype html>
<html lang="fi">
<head>
<script src="http://localhost/csstatic/dfa/rpn.js"></script>
 <style>
  .argsdiv {font-size: xx-large; margin-left: 1em;}
  .selarg {background-color: yellow; border-style: inset;}
  .buttondiv {margin-top: 1em; margin-left: 2em;}
  .buttondiv button {font-size: x-large;}
  .hidden {visibility: hidden;}
  .accept {background-color: lime;}
  .reject {background-color: red;}
  .accepttext {position: relative; top: -15px;}
 </style>
 <title>RPN</title>
</head>
<body>
<div style="margin-bottom: 3px"><span id="error" style="color: red;"></span>
</div>
<span id="argsdiv" class="argsdiv"></span>&nbsp;&nbsp;
<span id="accepttext" class="accepttext" ></span>
<canvas id="canvas" width=700 height=10 style="border-style:solid;border-width:1px;border-color:black;">
</canvas>
<div id="buttondiv" class="buttondiv">
  <button onclick="jumpToStart()" title="reset">|&lt;</button>
  <button onclick="animateBack()" title="animate back to start">&lt;&lt;&lt;</button>
  <!--<button onclick="animateBack(1)" title="animate one step back">&lt;&lt;</button> -->
  <button onclick="stepBack()" title="back minor step">&lt;</button>
  <button onclick="stepFwd()" title="do minor step">&gt;</button>
  <!--<button onclick="animateFwd(1)" title="animate one step">&gt;&gt;</button>-->
  <button onclick="animateFwd()" title="animate to end">&gt;&gt;&gt;</button>
  <button onclick="jumpToEnd()" title="run to end">&gt;|</button>
</div>
<script>
  let canvas = document.getElementById("canvas");
  let context = canvas.getContext("2d");
  let argsdiv = document.getElementById('argsdiv');
  let buttondiv = document.getElementById('buttondiv');
  let errspan = document.getElementById('error');
  let accepttext = document.getElementById('accepttext');


  class RPNState {
      reset() {
          this.step = -1;
          this.error = false;
          this.rpn.init();
      }

      constructor(rpn, args) {
          this.rpn = rpn;
          this.args = args;
          this.params = rpn.params;
          this.reset();
          this.maxStep = this.rpn.runUntil();
          this.maxStack = this.rpn.maxStack;
          this.reset();
      }

      /*!
       * Take one step forward in rpnState
       * \fn boolean forward()
       * \return boolean could it go forward
       */
      forward() {
          let step = this.step;
          if (this.step >= 0 && this.error) return false;
          if (this.step < 0) {
              this.step = 0;
              this.error = false;
              step = 0;
          }
          let oldEnd = this.rpn.isEnd();
          step++;
          this.rpn.runUntil(step);
          if (!oldEnd) this.step = step;
          else return false; // can not forward anymmore

          return true;
      }

      backward() {
          let step = this.step - 1;
          if (step < -1) return false;
          this.reset();
          // while (this.step < step) this.forward();
          this.step = this.rpn.runUntil(step);
          return true;
      }

      jumpToEnd() {
          this.step = this.maxStep;
          this.rpn.runUntil();
      }
} // RPNState


  class VisualRPNState extends RPNState {
      constructor(rpn, args) {
          super(rpn, args);
      }


      /*!
       * Draw whole rpn. Use also it's args to draw input
       * \fn makeViz(rpn)
       * \param json rpn structure of rpn
       */
      drawrpn() {
          let stackItemHeight = 30;
          let stackItemWidth = 50;
          let commandTextHeight = 30;
          let stackY = this.maxStack * stackItemHeight;
          let stackX = 300;
          let commandY = this.rpn.commands.length * commandTextHeight + 20;
          canvas.height = Math.max(stackY + stackItemHeight, commandY);
          context.clearRect(0, 0, canvas.width, canvas.height);
          context.font = "18px Arial";
          context.textAlign = "left";
          context.textBaseline = "middle";
          let code = this.rpn.commands;
          let line = this.rpn.stepnumber;
          for (let i = 0; i < code.length; i++) {
              let color = i === line ? "red" : "black";
              context.fillStyle = color;
              // context.fillText((i + 1), 10, 30+i*30);
              context.fillText(code[i].showText(), 20, 30 + i * commandTextHeight);
          }
          let stack = this.rpn.stack;
          context.textAlign = "center";
          let y = stackY;
          context.beginPath();
          context.rect(stackX - stackItemWidth/2, y + stackItemHeight/2, stackItemWidth*2, 5);
          context.stroke();
          for (let i = 0; i < stack.length; i++) {
              context.beginPath();
              context.rect(stackX, y - stackItemHeight/2, stackItemWidth, stackItemHeight);
              context.stroke();
              context.fillStyle = "black";
              context.fillText(stack[i], stackX + stackItemWidth/2, y);
              y -= stackItemHeight;
          }

          if (this.rpn.errors) {
              errspan.innerText = this.rpn.errors;
          } else {
              errspan.innerText = "";
          }
      }

      update() {
         this.drawrpn();
      }

  } // VisualRPNState


  let rpnState = null;

  function jumpToStart() {
      stop();
      rpnState.reset();
      rpnState.update();
  }

  function stepFwd() {
      stop();
      rpnState.forward();
      rpnState.update();
  }

  function stepBack() {
      stop();
      rpnState.backward();
      rpnState.update();
  }

  let timer;

  function stop() {
    clearInterval(timer);
  }

  function animate(rpnState, _n, call, until) {
    clearInterval(timer);
    // if ( n === undefined ) n = 10000;
    let step = 0;
    if (rpnState.step >= 0) step = rpnState.step;
    if ( step <= 0 ) step = -1;
    timer = setInterval(function() {
        if (until(step)) {
          clearInterval(timer);
          return;
        }
        if (!call()) clearInterval(timer);
        rpnState.update();
    },500)
  }

  function animateFwd(n) {
      stop();
      animate(rpnState, n, () => rpnState.forward(), (_step) => false)
  }

  function animateBack(n) {
      stop();
      animate(rpnState, n, () => rpnState.backward(), (_step) => false);
  }

  function jumpToEnd() {
      stop();
      rpnState.jumpToEnd();
      rpnState.update();
  }

  function preCheck(data) {
     if (!data) return false;
     if (!data.params) return false;
     let args = data.args || data.params.args;
     if (!args) return;
     args = (""+args).trim();
     data.args = args;
     let illegal = data.params.illegal;
     if (!illegal) return false;
     for (let s of illegal) {
        let re = new RegExp("^"+s+"$");
        if (args.match(re)) {
            errspan.innerText = "Laiton jono: " + args;
            return true;
        }
     }
     return false;
  }


  function paramDefault(params, name, value) {
      if (params[name] === undefined) params[name] = value;
  }


  function setData(data) {
    if ( preCheck(data) ) return;
    let params = data.params;
    if (!params) params = { };
    paramDefault(params, "acceptText", "accept");
    paramDefault(params, "rejectText", "reject");
    params["initial"] = data["args"];
    let rpn = new RPN(data.code, params);
    rpnState = new VisualRPNState(rpn, data.args);
    rpnState.drawrpn();
  }

</script>
  <script>
    const code = `
SWAP
POP
pop
pop2
     `;
    // setData({code: code, args: "abaa", params: {initial: "3,2"}});
    // console.log(rpnState.rpn.accepts("abaa"));
  </script>
</body>

</html>
