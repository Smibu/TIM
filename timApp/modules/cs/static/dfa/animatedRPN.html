<!doctype html>
<html lang="fi">
<head>
<script src="http://localhost/csstatic/dfa/rpn.js"></script>
 <style>
  .buttondiv {margin-top: 1em; margin-left: 2em;}
  .buttondiv button {font-size: x-large;}
  .explspan {font-size: x-large; color: blue; }
  .hidden {visibility: hidden;}
  body {
      margin: 0;
  }
 </style>
 <title>RPN</title>
</head>
<body>
<div id="maindiv">
<div style="margin-bottom: 3px">
    <span id="error" style="color: red;"></span>
    <span id="expls" class="explspan"></span>
</div>
<canvas id="canvas" width=700 height=10 >
</canvas>
<div id="buttondiv" class="buttondiv">
  <button onclick="jumpToStart()" title="reset">|&lt;</button>
  <button onclick="animateBack()" title="animate back to start">&lt;&lt;&lt;</button>
  <!--<button onclick="animateBack(1)" title="animate one step back">&lt;&lt;</button> -->
  <button onclick="stepBack()" title="back minor step">&lt;</button>
  <button onclick="stepFwd()" title="do minor step">&gt;</button>
  <!--<button onclick="animateFwd(1)" title="animate one step">&gt;&gt;</button>-->
  <button onclick="animateFwd()" title="animate to end">&gt;&gt;&gt;</button>
  <button onclick="jumpToEnd()" title="run to end">&gt;|</button>
</div>
</div>
<script>
  let canvas = document.getElementById("canvas");
  let context = canvas.getContext("2d");
  let buttondiv = document.getElementById('buttondiv');
  let errspan = document.getElementById('error');
  let expls = document.getElementById('expls');


  class RPNState {
      reset() {
          this.step = -1;
          this.error = false;
          this.rpn.init();
      }

      constructor(rpn) {
          this.rpn = rpn;
          this.params = rpn.params;
          this.reset();
          this.maxStep = this.rpn.runUntil();
          this.maxStack = this.rpn.maxStack;
          this.errorlines = "";
          let errlines = this.rpn.errors.trim();
          if (errlines) {
              errlines = errlines.split("\n");
              this.errorlines = errlines.length;
          }
          this.keep2stack = this.params["keep2stack"];
          this.reset();
      }

      /*!
       * Take one step forward in rpnState
       * \fn boolean forward()
       * \return boolean could it go forward
       */
      forward() {
          let step = this.step;
          if (this.step >= 0 && this.error) return false;
          if (this.step < 0) {
              this.step = 0;
              this.error = false;
              step = 0;
          }
          let oldEnd = this.rpn.isEnd();
          step++;
          this.rpn.runUntil(step);
          if (!oldEnd) this.step = step;
          else return false; // can not forward anymmore

          return true;
      }

      backward() {
          let step = this.step - 1;
          if (step < -1) return false;
          this.reset();
          // while (this.step < step) this.forward();
          this.step = this.rpn.runUntil(step);
          return true;
      }

      jumpToEnd() {
          this.step = this.maxStep;
          this.rpn.runUntil();
      }
} // RPNState


  class VisualRPNState extends RPNState {
      constructor(rpn, args) {
          super(rpn, args);
      }


      /*!
       * Draw whole rpn. Use also it's args to draw input
       * \fn makeViz(rpn)
       * \param json rpn structure of rpn
       */
      drawrpn() {
          let stackItemHeight = 30;
          let stackItemWidth = 50;
          let commandTextHeight = 30;
          let stackY = this.maxStack * stackItemHeight;
          let stackX = 200;
          let stack2X = stackX + 3*stackItemWidth;
          let commandY = this.rpn.commands.length * commandTextHeight;
          canvas.height = Math.max(stackY + stackItemHeight, commandY);
          context.clearRect(0, 0, canvas.width, canvas.height);
          context.font = "18px Arial";
          context.textAlign = "left";
          context.textBaseline = "middle";
          let code = this.rpn.commands;
          let line = this.rpn.stepnumber;
          for (let i = 0; i < code.length; i++) {
              let x = 20;
              let y = 15 + i * commandTextHeight;
              let h = commandTextHeight;
              let txt = code[i].showText();
              if (i === line && !code[i].isEnd()) {
                context.fillStyle = 'yellow';
                let width = context.measureText("PUSH 100000").width;
                context.fillRect(x-10, y - h/2, width, commandTextHeight);
              }
              context.fillStyle = i === line ? "red" : "black";
              // context.fillText((i + 1), 10, 30+i*30);
              context.fillText(txt, x, y);
          }

          drawStack(this.rpn.stack, stackX, "black");
          this.rpn2.runUntil(Math.max(this.step+1,1));
          let clr = this.rpn2.params["stack2Color"];
          if (clr && (!this.rpn.isEnd() || this.keep2stack)) {
              context.fillStyle = clr;
              let arrow = this.params["arrow"];
              if (arrow) context.fillText(arrow, stackX + (stack2X - stackX)/2 + stackItemWidth / 2, stackY);
              drawStack(this.rpn2.stack, stack2X, clr);
          }

          function drawStack(stack, x, color) {
              context.fillStyle = color;
              context.strokeStyle = color;
              context.textAlign = "center";
              let y = stackY;
              context.beginPath();
              context.rect(x - stackItemWidth / 2, y + stackItemHeight / 2, stackItemWidth * 2, 5);
              context.stroke();
              for (let i = 0; i < stack.length; i++) {
                  context.beginPath();
                  context.rect(x, y - stackItemHeight / 2, stackItemWidth, stackItemHeight);
                  context.stroke();
                  context.fillText(stack[i], x + stackItemWidth / 2, y);
                  y -= stackItemHeight;
              }
          }

          if (this.rpn.createErrors || this.errorlines) {
              let errors = this.rpn.errors;
              if (this.errorlines) {
                  let errlines = errors.split("\n").length;
                  // "" -> 1,  "1\n" -> 2, "1\n2\n" -> 3
                  errors += "\n".repeat(this.errorlines-errlines+1);
              }
              errspan.innerText = this.rpn.createErrors + errors;
          } else {
              errspan.innerText = "";
          }
          let cmd = this.rpn.currentCmd();
          if (cmd) { // reserve space for expl if used in this program
              let expl = "";
              if (cmd.expl) expl = "&nbsp;".repeat(3) + cmd.expl +"<br>&nbsp;";
              else if (this.rpn.explcount > 0) expl = "&nbsp;<br>&nbsp;";
              expls.innerHTML = expl;
          }
      }

      update() {
         this.drawrpn();
      }

  } // VisualRPNState


  let rpnState = null;

  function jumpToStart() {
      stop();
      rpnState.reset();
      rpnState.update();
  }

  function stepFwd() {
      stop();
      rpnState.forward();
      rpnState.update();
  }

  function stepBack() {
      stop();
      rpnState.backward();
      rpnState.update();
  }

  let timer;

  function stop() {
    clearInterval(timer);
  }

  function animate(rpnState, _n, call, until) {
    clearInterval(timer);
    // if ( n === undefined ) n = 10000;
    let step = 0;
    if (rpnState.step >= 0) step = rpnState.step;
    if ( step <= 0 ) step = -1;
    timer = setInterval(function() {
        if (until(step)) {
          clearInterval(timer);
          return;
        }
        if (!call()) clearInterval(timer);
        rpnState.update();
    },500)
  }

  function animateFwd(n) {
      stop();
      animate(rpnState, n, () => rpnState.forward(), (_step) => false)
  }

  function animateBack(n) {
      stop();
      animate(rpnState, n, () => rpnState.backward(), (_step) => false);
  }

  function jumpToEnd() {
      stop();
      rpnState.jumpToEnd();
      rpnState.update();
  }

  function preCheck(data) {
     if (!data) return false;
     if (!data.params) return false;
     let args = data.args || data.params.args;
     if (!args) return;
     args = (""+args).trim();
     data.args = args;
     let illegal = data.params.illegal;
     if (!illegal) return false;
     for (let s of illegal) {
        let re = new RegExp("^"+s+"$");
        if (args.match(re)) {
            errspan.innerText = "Laiton jono: " + args;
            return true;
        }
     }
     return false;
  }


  function paramDefault(params, name, value) {
      if (params[name] === undefined) params[name] = value;
  }


  function setData(data) {
    if ( preCheck(data) ) return;
    let params = data.params;
    if (!params) params = { };
    paramDefault(params, "stack2color", "");
    params["initial"] = data.args;
    let rpn = new RPN(data.code, params);
    let rpn2 = new RPN(data.code, params);
    rpnState = new VisualRPNState(rpn);
    rpnState.rpn2 = rpn2;
    rpnState.drawrpn();
    return {iframe: {height: document.body.clientHeight+3}};
  }

</script>
  <script>
    const code = `
SWAP
POP
pop
pop2
     `;
    // setData({code: code, args: "abaa", params: {initial: "3,2"}});
    // console.log(rpnState.rpn.accepts("abaa"));
  </script>
</body>

</html>
